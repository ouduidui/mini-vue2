{"version":3,"file":"vue.min.js","sources":["../src/observer/dep.js","../src/observer/index.js","../src/util/next-tick.js","../src/observer/scheduler.js","../src/observer/watcher.js","../src/instance/state.js","../src/instance/lifecycle.js","../src/compiler/parse.js","../src/compiler/generate.js","../src/compiler/index.js","../src/vdom/patch.js","../src/vdom/vnode.js","../src/vdom/create-component.js","../src/vdom/create-element.js","../src/instance/render.js","../src/util/options.js","../src/instance/events.js","../src/instance/inject.js","../src/instance/index.js","../src/shared/constants.js","../src/global-api/extend.js","../src/global-api/assets.js","../src/global-api/index.js","../src/index.js"],"sourcesContent":["let uid = 0;\n\n/**\n * Dep: 负责通知监听器更新\n */\nexport class Dep {\n    static target = null;\n\n    constructor() {\n        this.id = uid++;  // Dep id\n        this.subs = [];  // 存放Watcher\n    }\n\n    /**\n     * addDep: 添加新的监听器\n     * @param sub\n     */\n    addSub(sub) {\n        this.subs.push(sub)\n    }\n\n    /**\n     * notify: 通知更新\n     */\n    notify() {\n        this.subs.forEach(dep => dep.update());\n    }\n\n    /**\n     * depend: watcher实例中添加dep\n     */\n    depend() {\n        if (Dep.target) {\n            Dep.target.addDep(this)\n        }\n    }\n}\n\nconst targetStack = []\n\n/**\n * pushTarget: 设置Dep.target\n * @param target: Watcher实例\n */\nexport function pushTarget(target) {\n    targetStack.push(target)\n    Dep.target = target\n}\n\n/**\n * popTarget: 重置Dep.target\n */\nexport function popTarget() {\n    targetStack.pop()\n    Dep.target = targetStack[targetStack.length - 1]\n}","import {Dep} from \"./dep\";\n\n/**\n * observe: 将整个对象设置为响应式数据\n * @param value<Object>: 对象\n */\nexport function observe(value) {\n    // 判断响应式数据是否为对象\n    if (typeof value !== 'object' || value === null) {\n        return;\n    }\n\n    // 响应式处理\n    return new Observer(value);\n}\n\n/**\n * Observer: 根据传入value的类型做响应的响应式处理\n * @param value<Object>: 对象\n */\nclass Observer {\n    constructor(value) {\n        this.value = value;\n        // 创建Dep实例\n        this.dep = new Dep();\n\n        // 在每一个value设置一个__ob__属性，值为对应的Observer实例\n        Object.defineProperty(value, '__ob__', {value: this})\n\n        // 判断类型\n        if (Array.isArray(value)) {    // 数组\n            // 覆盖原生方法\n            copyAugment(value);\n            // 响应式处理\n            this.observeArray(value);\n        } else {  // 对象\n            // 响应式处理\n            this.walk(value);\n        }\n    }\n\n    /**\n     * observeArray: 遍历数组进行响应式处理\n     * @param items<Array>: 数组\n     */\n    observeArray(items) {\n        for (let i = 0, l = items.length; i < l; i++) {\n            observe(items[i])\n        }\n    }\n\n    /**\n     * Observer: 根据传入value的类型做响应的响应式处理\n     * @param obj<Object>: 对象\n     */\n    walk(obj) {\n        // 遍历所有属性，执行defineReactive\n        Object.keys(obj).forEach(key => {\n            defineReactive(obj, key, obj[key]);\n        })\n    }\n}\n\n/**\n * copyAugment: 复制一份数组原型，修改原型方法\n * @param value<Array>: 数组\n */\nfunction copyAugment(value) {\n    const ob = value.__ob__;\n    // 创建新的数组原型\n    const original = Array.prototype;\n    // 以Array.prototype为原型创新一个新对象\n    const arrayProto = Object.create(original);\n    // 涉及到数据改动的七个数组方法\n    const methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n\n    methodsToPatch.forEach(method => {\n        arrayProto[method] = function (...args) {\n            // 原始操作\n            original[method].apply(this, args);\n            // 如果是插入动作，对新插入的元素进行响应式处理\n            let inserted;\n            switch (method) {\n                case 'push':\n                case 'unshift':\n                    inserted = args\n                    break\n                case 'splice':\n                    inserted = args.slice(2)\n                    break\n            }\n            // 若有新增则做响应处理\n            if (inserted) {\n                ob.observeArray(inserted)\n            }\n\n            // 通知更新\n            ob.dep.notify();\n        }\n    })\n\n    // 覆盖原型\n    value.__proto__ = arrayProto;\n}\n\n/**\n * defineReactive : 将对象中某一个属性设置为响应式数据\n * @param obj<Object>: 对象\n * @param key<any>: key名\n * @param val<any>: 初始值\n */\nexport function defineReactive(obj,key,val) {\n    // 递归处理：如果val是对象，继续做响应式处理\n    let childOb = observe(val);\n\n    const dep = new Dep();\n\n    Object.defineProperty(obj, key, {\n        get() {\n            // 依赖收集\n            // Dep.target && dep.addDep(Dep.target);\n            dep.depend();\n\n            // 若存在子observer，则依赖也追加到子ob\n            if (childOb) {\n                childOb.dep.depend()\n                if (Array.isArray(val)) {\n                    dependArray(val)  // 数组需特殊处理\n                }\n            }\n            return val;\n        },\n        set(newVal) {\n            if(newVal !== val) {    // 此时val存在obj的闭包里面\n                observe(newVal);   // 如果newVal是对象，再次做响应式处理\n                val = newVal;\n                // 通知更新\n                dep.notify();\n            }\n        }\n    })\n}\n\n/**\n * dependArray : 对数组每一项进行依赖收集\n * @param value<Array>: 数组\n */\nfunction dependArray(value) {\n    value.forEach(v => {\n        // 数组每一项都需要依赖收集\n        v && v.__ob__ && v.__ob__.dep.depend();\n        if(Array.isArray(v)){\n            dependArray(v)\n        }\n    })\n}\n\n/**\n * $set: 设置响应式数据\n * @param target\n * @param key\n * @param val\n */\nexport function set(target, key, val) {\n    const ob = target.__ob__;\n\n    if(!ob) {\n        target[key] = val;\n        return val;\n    }\n\n    // 响应式处理\n    defineReactive(ob.value, key, val)\n    // 依赖收集\n    ob.dep.notify()\n    return val;\n}\n\n/**\n * $set: 删除响应式数据\n * @param target\n * @param key\n */\nexport function del(target, key) {\n    const ob = target.__ob__;\n    // 删除对应的值\n    delete target[key];\n\n    if(!ob){\n        return;\n    }\n    // 通知更新\n    ob.dep.notify();\n}","// 存放回调函数\nconst callbacks = [];\n// 判断是否在执行异步\nlet pending = false;\n\n// 将callbacks数组中所有回调函数都执行一遍\nfunction flushCallbacks() {\n    // 状态设为false\n    pending = false;\n    // 浅复制一份callbacks，然后将其清空\n    const copies = callbacks.slice(0);\n    callbacks.length = 0;\n    // 遍历调用\n    for(let i = 0; i < copies.length; i++) {\n        copies[i]()\n    }\n}\n\nlet timerFunc;\n// 初始timerFunc\nif(typeof Promise !== 'undefined') {  // 优先选择Promise\n    const p = Promise.resolve();\n    timerFunc = () => {\n        p.then(flushCallbacks);\n    }\n}else if(typeof MutationObserver !== 'undefined') { // MutationObserver\n    let counter = 1;\n    const observer = new MutationObserver(flushCallbacks);\n    const textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n        characterData: true\n    })\n    timerFunc = () => {\n        counter = (counter + 1) % 2;\n        textNode.data = String(counter);\n    }\n}else if(typeof setImmediate !== 'undefined') {  // setImmediate\n    timerFunc = () => {\n        setImmediate(flushCallbacks)\n    }\n}else {   // setTimeout\n    timerFunc = () => {\n        setTimeout(flushCallbacks, 0)\n    }\n}\n\nexport function nextTick(cb, ctx) {\n    // 将回调函数放入数组\n    callbacks.push(() => {\n        if(cb) {\n            // 执行回调函数\n            cb.call(ctx);\n        }\n    })\n\n    if(!pending) {\n        pending = true;\n        // 异步执行callbacks任务\n        timerFunc();\n    }\n}\n","import {nextTick} from \"../util/next-tick\";\n\nconst queue = [];\nlet has = {};\nlet waiting = false;\nlet flushing = false;\nlet index = 0;\n\nfunction resetSchedulerState() {\n    index = queue.length = 0;\n    has = {};\n    waiting = flushing = false;\n}\n\nfunction flushSchedulerQueue() {\n    flushing = true;\n    let watcher, id;\n\n    // 按照id的顺序执行watcher更新\n    queue.sort((a, b) => a.id - b.id);\n    for (index = 0; index < queue.length; index++) {\n        watcher = queue[index];\n        id = watcher.id;\n        // 将正在更细你的watcher从映射表清空\n        has[id] = null;\n        // 执行更新函数\n        watcher.run();\n    }\n\n    // 重置队列和状态\n    resetSchedulerState();\n}\n\n// 将watcher插入队列\nexport function queueWatcher(watcher) {\n    const id = watcher.id;\n\n    // 去重，单个watcher只需要入队一次即可\n    if (!has[id] || has[id] === null) {\n        has[id] = true;  // 记录已经入队的id\n\n        // 判断是否正在遍历更新\n        if (!flushing) {\n            queue.push(watcher);\n        } else {\n            // 如果正在遍历更新的话，将watcher按照id顺序插入\n            let i = queue.length - 1;\n            while (i > index && queue[i].id > watcher.id) {\n                i--\n            }\n            // 将当前watcher插入队列中\n            queue.splice(i + 1, 0, watcher);\n        }\n\n        if (!waiting) {\n            waiting = true;\n            // 异步方式将flushSchedulerQueue放入微任务队列\n            nextTick(flushSchedulerQueue);\n        }\n    }\n}\n","import {popTarget, pushTarget} from \"./dep\";\nimport {queueWatcher} from \"./scheduler\";\n\nlet uid = 0\n\n/**\n * Watcher: 监听器 —— 负责依赖更新\n * @param vm: vue实例\n * @param expOrFn: 更新函数\n * @param cb: 回调函数\n */\nexport class Watcher {\n    constructor(vm, expOrFn, cb) {\n        this.id = ++uid\n        this.vm = vm;\n        this.cb = cb;\n        this.depIds = new Set();\n        this.deps = [];\n\n        if(typeof expOrFn === 'function'){\n            this.getter = expOrFn;\n        }else {\n            // 这种是$watch传递进来的表达式，它们需要解析为函数\n            this.getter = parsePath(expOrFn)\n        }\n\n        // 触发依赖收集\n        this.value = this.get();\n    }\n\n    get() {\n        let value;\n        // 将this赋值给Dep的target属性\n        pushTarget(this);\n        // 触发收集\n        value = this.getter.call(this.vm, this.vm);\n        // 收集完成后，将target设置回null\n        popTarget();\n\n        return value;\n    }\n\n    update() {\n        // this.run();\n        // 异步执行更新函数\n        queueWatcher(this);\n    }\n\n    run() {\n        // 调用watcher的get方法，获取更新函数updateComponent方法\n        const value = this.get()\n        if(value !== this.value) {\n            const oldValue = this.value;\n            this.value = value;\n            this.cb.call(this.vm, value, oldValue);\n        }\n    }\n\n    addDep(dep){\n        const id = dep.id;\n        if (!this.depIds.has(id)) {\n            // 添加当前watcher和传入dep的关系\n            this.depIds.add(id);\n            this.deps.push(dep);\n            // 反向给dep添加当前watcher关系\n            dep.addSub(this);\n        }\n    }\n\n    // 全部遍历依赖收集\n    depend(){\n        let i = this.deps.length\n        while (i--) {\n            this.deps[i].depend()\n        }\n    }\n}\n\nfunction parsePath (path) {\n    const segments = path.split('.')\n    return function (obj) {\n        for (let i = 0; i < segments.length; i++) {\n            if (!obj) return\n            obj = obj[segments[i]]\n        }\n        return obj\n    }\n}\n","import {observe} from \"../observer/index\";\nimport {defineReactive} from \"../observer/index\";\nimport {Dep} from \"../observer/dep\";\nimport {Watcher} from \"../observer/watcher\";\n\nconst sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: function(){},\n    set: function(){}\n}\n\n/**\n * Vue: 包含el、data、methods等等\n * @param vm<Object>: Vue实例\n */\nexport function initState(vm) {\n    // 获取options\n    const opts = vm.$options;\n\n    // 初始化顺序 props -> methods -> data -> computed -> watch\n    if (opts.props) initProps(vm, opts.props)\n    if (opts.methods) initMethods(vm, opts.methods)\n    if (opts.data) {\n        initData(vm)\n    } else {\n        observe(vm._data = {})  // 没有data数据的话，默认为{}\n    }\n\n    if (opts.computed) {\n        initComputed(vm, opts.computed);  // 初始化computed\n    }\n\n    if (opts.watch) {\n        initWatch(vm, opts.watch)  // 初始化watch\n    }\n}\n\n/**\n * initData: 初始化data数据\n * @param vm<Object>: Vue实例\n */\nfunction initData(vm) {\n    let data = vm.$options.data;\n\n    // 如果data是函数\n    if (typeof data === 'function') {\n        const res = data.call(vm, vm);\n        data = typeof res !== 'object' || res === null ? {} : res;\n    }\n\n    vm._data = data;\n\n    // 数据代理\n    for(const key in data) {\n        proxy(vm, '_data', key);\n    }\n\n    // 响应式处理\n    observe(vm._data);\n}\n\n/**\n * proxy: 数据代理\n * @param vm<Object>: Vue实例\n * @param sourceKey\n * @param key\n */\nfunction proxy(vm, sourceKey, key) {\n    Object.defineProperty(vm, key, {\n        get() {\n            return vm[sourceKey][key]\n        },\n        set(newVal) {\n            vm[sourceKey][key] = newVal;\n        }\n    })\n}\n\n/**\n * initComputed: 初始化computed\n * @param vm<Object>: Vue实例\n * @param computed<Object>\n */\nfunction initComputed(vm, computed) {\n    const watchers = vm._computedWatchers = Object.create(null);\n\n    // 遍历computed\n    for (const key in computed) {\n        const userDef = computed[key]\n        // 获取getter\n        const getter = typeof userDef === 'function' ? userDef : userDef.get;\n        // 建立Watcher实例\n        watchers[key] = new Watcher(vm, getter, () =>{})\n\n        if (!(key in vm)) {  // 避免重名\n            sharedPropertyDefinition.get = function () {\n                const watcher = this._computedWatchers && this._computedWatchers[key];\n                if(watcher) {\n                    if(Dep.target) {\n                        watcher.depend();\n                    }\n                    return watcher.value;\n                }\n            };\n\n            Object.defineProperty(vm, key, sharedPropertyDefinition)\n        }\n    }\n}\n\n/**\n * initWatch: 初始化watch\n * @param vm<Object>: Vue实例\n * @param watch<Object>\n */\nfunction initWatch(vm, watch) {\n    for (const key in watch) {\n        const handler = watch[key]\n        if (Array.isArray(handler)) {\n            for (let i = 0; i < handler.length; i++) {\n                createWatcher(vm, key, handler[i])\n            }\n        } else {\n            createWatcher(vm, key, handler)\n        }\n    }\n}\n\n/**\n * createWatcher: 创建监听器\n * @param vm<Object>: Vue实例\n * @param expOrFn<String>\n * @param handler<Function>\n */\nfunction createWatcher(vm, expOrFn, handler) {\n    if (typeof handler === 'string') {\n        handler = vm[handler]\n    }\n    return vm.$watch(expOrFn, handler)\n}\n\n/**\n * initWatch: 初始化props\n * @param vm<Object>: Vue实例\n * @param propsOptions<Object>\n */\nfunction initProps(vm, propsOptions) {\n    const propsData = vm.$options.propsData || {};\n    const props = vm._props = {};\n    vm.$options._propKeys = [];\n\n    for(const key in propsOptions) {\n        vm.$options._propKeys.push(key);\n        const prop = propsOptions[key];\n        const value = propsData[key] || prop.default;\n        defineReactive(props, key, value);\n        if(!(key in vm)){\n            proxy(vm,'_props', key);\n        }\n    }\n}\n\n/**\n * initWatch: 初始化methods\n * @param vm<Object>: Vue实例\n * @param methods<Object>\n */\nfunction initMethods(vm, methods) {\n    for(const key in methods) {\n        vm[key] = methods[key].bind(vm)\n    }\n}\n","import {Watcher} from \"../observer/watcher\";\n\n// 正在构建的实例\nexport let activeInstance = null\n\n/**\n * initLifecycle: 初始化生命周期\n * @param vm: 组件实例\n */\nexport function initLifecycle(vm) {\n    const options = vm.$options\n    // 父节点\n    let parent = options.parent\n    if (parent) {\n        parent.$children.push(vm)\n    }\n    vm.$parent = parent\n    // 根节点\n    vm.$root = parent ? parent.$root : vm\n    // 函数节点\n    vm.$children = []\n    // 自定义组件\n    vm.$refs = {}\n}\n\nexport function mountComponent(vm, hook) {\n    // beforeMount生命周期钩子\n    callHook(vm, 'beforeMount');\n\n    // 创建更新函数\n    const updateComponent = () => {\n        vm._update(vm._render());\n    }\n\n    // 创建监听器\n    new Watcher(vm, updateComponent);\n\n    if(!vm.$vnode) {\n        // mount生命钩子\n        callHook(vm, 'mounted');\n    }\n}\n\n/**\n * callHook: 钩子调用\n * @param vm: 组件实例\n * @param hook: 钩子名称\n */\nexport function callHook(vm, hook) {\n    // 获取对应钩子函数\n    const handler = vm.$options[hook];\n    if (handler) {\n        try {\n            handler.call(vm);\n        }catch (e){\n            console.log(e);\n        }\n    }\n}\n\nexport function setActiveInstance(vm) {\n    const prevActiveInstance = activeInstance;  // 保存上一个构建的实例\n    activeInstance = vm  // 更新准备构建的实例\n    // 返回一个重置函数\n    return () => {\n        activeInstance = prevActiveInstance\n    }\n}\n\nexport function updateChildComponent(vm, propsData, listeners, parentVnode) {\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode;\n    if(vm._vnode) {\n        vm._vnode.parent = parentVnode;\n    }\n\n    // 更新props\n    if(propsData && vm.$options.props) {\n        const propsKeys = vm.$options._propKeys || [];\n        propsKeys.forEach(key => {\n            vm._props[key] = propsData[key];\n        })\n        vm.$options.propsData = propsData;\n    }\n}\n","/**\n * 解析模版字符串，生成 AST 语法树\n * @param {*} template 模版字符串\n * @returns {AST} root ast 语法树\n */\nexport default function parse(template) {\n    // 存放所有的未配对的开始标签的AST对象\n    const stack = [];\n    // 最终的AST语法树\n    let root = null;\n\n    let html = template;\n\n    while (html.trim()) {\n        // 过滤注释标签\n        if (html.indexOf('<!--') === 0) {\n            // 说明开始位置是一个注释标签\n            html = html.slice(html.indexOf('-->') + 3);\n        }\n\n        // 匹配开始标签\n        const startIdx = html.indexOf('<');\n        if (startIdx === 0) {\n            if (html.indexOf('</') === 0) {\n                // 闭合标签\n                parseEnd();\n            } else {\n                // 开始标签\n                parseStartTag();\n            }\n        } else if (startIdx > 0) {\n            // 文本内容\n            if (stack.length) {\n                processChars(html.slice(0, startIdx));\n            }\n            html = html.slice(startIdx);\n        }\n    }\n\n    return root;\n\n\n    /**\n     * 处理结束标签\n     */\n    function parseEnd() {\n        // 将结束标签从html字符中截掉\n        html = html.slice(html.indexOf('>') + 1);\n        // 处理栈顶元素\n        processElement();\n    }\n\n    /**\n     * 处理元素的闭合标签时会调用该方法\n     * 进一步处理元素上的各个属性，将处理结果放到 data 属性上\n     */\n    function processElement() {\n        // 弹出栈顶元素，进一步处理该元素\n        const curEle = stack.pop();\n        const stackLen = stack.length;\n        // 进一步处理 AST 对象中的rawAttr对象 {dataName: attrValue, ...}\n        const {tag, rawAttr} = curEle;\n        // 处理结果都放到attr对象上，并删除 rawAttr 对象中相应的属性\n        curEle.data = {};\n        // 属性对象的key组成的数组\n        const propertyArr = Object.keys(rawAttr);\n\n        // 处理vue指令\n        if (propertyArr.includes('v-model')) {\n            // 处理v-model\n            processVModel(curEle);\n            // 删除\n            delete rawAttr['v-model'];\n        }\n        if (propertyArr.find(item => item.match(/^:(.*)/) || item.match(/^v-bind:(.*)/))) {\n            // 处理v-bind指令\n            const value = rawAttr[`v-bind:${RegExp.$1}`] || rawAttr[`:${RegExp.$1}`]\n            processVBind(curEle, RegExp.$1, value)\n            // 删除\n            delete rawAttr[`v-bind:${RegExp.$1}`];\n            delete rawAttr[`:${RegExp.$1}`];\n        }\n        if (propertyArr.find(item => item.match(/^@(.*)/) || item.match(/^v-on:(.*)/))) {\n            // 处理v-on指令\n            const value = rawAttr[`v-on:${RegExp.$1}`] || rawAttr[`@${RegExp.$1}`]\n            processVOn(curEle, RegExp.$1, value)\n            // 删除\n            delete rawAttr[`v-on:${RegExp.$1}`];\n            delete rawAttr[`@${RegExp.$1}`];\n        }\n\n        // 节点处理完以后让其和父节点产生关系\n        if (stackLen) {\n            stack[stackLen - 1].children.push(curEle);\n            curEle.parent = stack[stackLen - 1];\n        }\n    }\n\n    /**\n     * 处理 v-model 指令，将处理结果直接放到 curEle 对象身上\n     * @param {*} curEle\n     */\n    function processVModel(curEle) {\n        const {tag, rawAttr, data} = curEle;\n        const {type, 'v-model': vModelVal} = rawAttr;\n\n        if (tag === 'input') {\n            data.vModel = {tag, type, value: vModelVal};\n        } else if (tag === 'textarea' || tag === 'select') {\n            data.vModel = {tag, value: vModelVal}\n        }\n    }\n\n    /**\n     * 处理 v-bind 指令\n     * @param {*} curEle 当前正在处理的 AST 对象\n     * @param {*} bindKey v-bind:key 中的 key\n     * @param {*} bindVal v-bind:key = val 中的 val\n     */\n    function processVBind(curEle, bindKey, bindVal) {\n        curEle.data.vBind = {[bindKey]: bindVal}\n    }\n\n\n    /**\n     * 处理 v-on 指令\n     * @param {*} curEle 当前被处理的 AST 对象\n     * @param {*} vOnKey v-on:key 中的 key\n     * @param {*} vOnVal v-on:key=\"val\" 中的 val\n     */\n    function processVOn(curEle, vOnKey, vOnVal) {\n        curEle.data.vOn = {[vOnKey]: vOnVal}\n    }\n\n    /**\n     * 解析开始标签\n     */\n    function parseStartTag() {\n        // 先找到开始标签的结束位置\n        const end = html.indexOf('>');\n        // 解析开始标签的内容\n        const content = html.slice(1, end);\n        // 截断html\n        html = html.slice(end + 1);\n\n        // 找到第一个空格位置\n        const firstSpaceIdx = content.indexOf(' ');\n        // 标签名和属性字符串\n        let tagName = '', attrsStr = '';\n        if (firstSpaceIdx === -1) {\n            // 没有属性\n            tagName = content;\n        } else {\n            tagName = content.slice(0, firstSpaceIdx);\n            attrsStr = content.slice(firstSpaceIdx + 1);\n        }\n\n        // 得到属性数组\n        const attrs = attrsStr ? attrsStr.split(' ') : [];\n        // 解析属性数组\n        const attrMap = parseAttrs(attrs);\n        // 生成AST对象\n        const elementAst = generateAST(tagName, attrMap);\n\n        // 如果根节点不存在，说明当前节点为整个模板的第一个节点\n        if (!root) {\n            root = elementAst;\n        }\n\n        // 将ast对象push到栈中，当遇到结束标签的时候就将栈顶的ast对象pop出来\n        stack.push(elementAst);\n\n        // 自闭合标签\n        if (isUnaryTag(tagName)) {\n            processElement();\n        }\n    }\n\n    /**\n     * 解析属性数组，得到一个属性 和 值组成的 Map 对象\n     * @param {*} attrs 属性数组，[id=\"app\", xx=\"xx\"]\n     */\n    function parseAttrs(attrs) {\n        const attrMap = {};\n        for (let i = 0, len = attrs.length; i < len; i++) {\n            const attr = attrs[i];\n            const [attrName, attrValue] = attr.split('=');\n            attrMap[attrName] = attrValue.replace(/[\"|']/g, \"\");\n        }\n        return attrMap;\n    }\n\n    /**\n     * 生成 AST 对象\n     * @param {*} tagName 标签名\n     * @param {*} attrMap 标签组成的属性 map 对象\n     */\n    function generateAST(tagName, attrMap) {\n        return {\n            // 元素节点\n            type: 1,\n            // 标签\n            tag: tagName,\n            // 原始属性\n            rawAttr: attrMap,\n            // 子节点\n            children: []\n        }\n    }\n\n    /**\n     * 是否为自闭合标签，内置一些自闭合标签，为了处理简单\n     */\n    function isUnaryTag(tagName) {\n        const unaryTag = ['input']\n        return unaryTag.includes(tagName)\n    }\n\n    /**\n     * 处理文本\n     * @param {string} text\n     */\n    function processChars(text) {\n        // 去除空格的情况\n        if (!text.trim()) return;\n\n        // 构造文本节点的AST\n        const textAst = {\n            type: 3,\n            text\n        }\n\n        // 表达式\n        if (text.match(/{{(.*)}}/)) {\n            textAst.expression = RegExp.$1.trim();\n        }\n\n        // 将AST放入栈顶标签内\n        stack[stack.length - 1].children.push(textAst);\n    }\n}\n","/**\n * 从 ast 生成渲染函数\n * @param {*} ast ast 语法树\n * @returns 渲染函数\n */\nexport default function generate(ast) {\n    // 渲染函数字符串形式\n    const renderStr = genElement(ast);\n    // 通过 new Function 将字符串形式的函数变成可执行函数，并用 with 为渲染函数扩展作用域链\n    return new Function(`with(this) { return ${renderStr} }`)\n}\n\n/**\n * 解析 ast 生成 渲染函数\n * @param {*} ast 语法树\n * @returns {string} 渲染函数的字符串形式\n */\nfunction genElement(ast) {\n    const {tag, rawAttr, data} = ast;\n\n    // 生成属性Map对象\n    const datas = {...rawAttr, ...data};\n\n    // 处理子节点\n    const children = genChildren(ast);\n\n    // 生成 VNode 的可执行方法\n    return `_c(this, '${tag}', ${JSON.stringify(datas)}, [${children}])`\n}\n\n/**\n * 处理 ast 节点的子节点，将子节点变成渲染函数\n * @param {*} ast 节点的 ast 对象\n * @returns [childNodeRender1, ....]\n */\nfunction genChildren(ast) {\n    const res = [], {children} = ast;\n\n    // 遍历所有子节点\n    for(let i = 0, len = children.length; i <len; i++) {\n        const child = children[i];\n        if(child.type === 3) {\n            // 文本节点\n            res.push(`_v(${JSON.stringify(child)})`);\n        }else if(child.type === 1) {\n            // 元素节点\n            res.push(genElement(child));\n        }\n    }\n\n    return res;\n}\n","import parse from \"./parse\";\nimport generate from \"./generate\";\n\n/**\n * 解析模版字符串，得到 AST 语法树\n * 将 AST 语法树生成渲染函数\n * @param { String } template 模版字符串\n * @returns 渲染函数\n */\nexport default function compileToFunction(template) {\n    // 解析模板，生成AST\n    const ast = parse(template);\n    // 将AST生成渲染函数\n    const render = generate(ast);\n\n    return render;\n}\n","/**\n * 初始渲染和后续更新的入口\n * @param oldVnode 老的 VNode\n * @param vnode 新的 VNode\n * @returns VNode 的真实 DOM 节点\n */\nexport function patch(oldVnode, vnode) {\n    // 新的节点不存在且旧节点存在：删除\n    if (oldVnode && !vnode) return;\n\n    let isInitialPatch = false;  // 判断是否新增节点\n    const insertedVnodeQueue = [];  // 新增节点队列\n\n    if (!oldVnode) {\n        isInitialPatch = true;\n        // 旧节点不存在且新节点存在：子组件首次渲染\n        createElm(vnode, insertedVnodeQueue);\n    } else {\n        if (!oldVnode.nodeType) {\n            // 比较新旧节点 diff算法\n            patchVnode(oldVnode, vnode, insertedVnodeQueue);\n        } else {// oldVnode为真实节点，初次加载\n            // 父节点，为body\n            const parent = oldVnode.parentNode;\n            // 参考节点，即老节点的下一个节点，新节点要插入参考节点之前\n            const referNode = oldVnode.nextSibling;\n            // 创建元素\n            createElm(vnode, insertedVnodeQueue, parent, referNode);\n\n            // 销毁旧节点\n            if (parent) {\n                parent.removeChild(oldVnode);\n            }\n        }\n    }\n    invokeInsertHook(insertedVnodeQueue);\n    return vnode.elm;\n}\n\n/**\n * 创建元素\n * @param {*} vnode\n * @param {*} insertedVnodeQueue\n * @param {*} parent 父节点，真实节点\n * @param {*} referNode 参考节点\n * @returns\n */\nfunction createElm(vnode, insertedVnodeQueue, parent, referNode) {\n    // 记录节点的父节点\n    vnode.parent = parent;\n    // 自定义组件\n    if (createComponent(vnode, insertedVnodeQueue, parent, referNode)) return\n\n    const {data, children, text} = vnode;\n\n    if(vnode.data) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n    }\n    if (text) {  // 文本节点\n        // 创建文本节点，并插入父节点内\n        vnode.elm = createTextNode(vnode);\n    } else {  // 元素节点\n        // 创建元素，在vnode上记录对应的dom节点\n        vnode.elm = document.createElement(vnode.tag);\n        // 设置属性\n        setAttribute(data, vnode);\n        // 递归遍历子节点\n        for (let i = 0, len = children.length; i < len; i++) {\n            createElm(children[i], insertedVnodeQueue,vnode.elm);\n        }\n    }\n\n    if (parent) {\n        const elm = vnode.elm;\n        if (referNode) {\n            parent.insertBefore(elm, referNode);\n        } else {\n            parent.appendChild(elm);\n        }\n    }\n\n}\n\n/**\n * 创建文本节点\n * @param {*} textVNode 文本节点的 VNode\n */\nfunction createTextNode(textVNode) {\n    let {text} = textVNode, textNode = null;\n\n    if (text.expression) {\n        // 表达式\n        const value = textVNode.context[text.expression];\n        textNode = document.createTextNode(\n            typeof value === 'object' ? JSON.stringify(value) : value\n        );\n    } else {\n        // 纯文本\n        textNode = document.createTextNode(text.text);\n    }\n\n    return textNode;\n}\n\n/**\n * 给节点设置属性\n * @param {*} data 属性 Map 对象\n * @param {*} vnode\n */\nfunction setAttribute(data, vnode) {\n    // 遍历属性，如果是普通属性，直接设置，如果是指令，则特殊处理\n    for (let name in data) {\n        if (name === 'vModel') {\n            // v-model 指令\n            const {tag, value} = data.vModel;\n            setVModel(tag, value, vnode);\n        } else if (name === 'vBind') {\n            // v-bind 指令\n            setVBind(vnode);\n        } else if (name === 'vOn') {\n            // v-on 指令\n            setVOn(vnode);\n        } else {\n            vnode.elm.setAttribute(name, data[name]);\n        }\n    }\n}\n\n/**\n * v-model 的原理\n * @param {*} tag 节点的标签名\n * @param {*} value 属性值\n * @param {*} vnode 节点\n */\nfunction setVModel(tag, value, vnode) {\n    const {context: vm, elm} = vnode;\n    if (tag === 'select') {\n        Promise.resolve().then(() => {\n            // 利用promise延迟设置，此时option元素还没创建\n            elm.value = vm[value];\n        })\n        elm.addEventListener('change', function () {\n            vm[value] = elm.value;\n        })\n    } else if (tag === 'input') {\n        if (vnode.elm.type === 'checkbox') {\n            elm.checked = vm[value];\n            elm.addEventListener('change', function () {\n                vm[value] = elm.checked;\n            })\n        } else {\n            elm.value = vm[value];\n            elm.addEventListener('input', function () {\n                vm[value] = elm.value;\n            })\n            elm.addEventListener('change', function () {\n                vm[value] = elm.value;\n            })\n        }\n    }\n}\n\n/**\n * v-bind 原理\n * @param {*} vnode\n */\nfunction setVBind(vnode) {\n    const {data: {vBind}, elm, context: vm} = vnode;\n    for (let attrName in vBind) {\n        elm.setAttribute(attrName, vm[vBind[attrName]]);\n        elm.removeAttribute(`v-bind:${attrName}`);\n        elm.removeAttribute(`:${attrName}`);\n    }\n}\n\n/**\n * v-on 原理\n * @param {*} vnode\n */\nfunction setVOn(vnode) {\n    const {data: {vOn}, elm, context: vm} = vnode;\n    for (let eventName in vOn) {\n        elm.addEventListener(eventName, function (...args) {\n            vm.$options.methods[vOn[eventName]].apply(vm, args);\n        })\n    }\n}\n\n/**\n * 对比新老节点，找出其中的不同，然后更新老节点\n * @param {*} oldVnode 老节点的 vnode\n * @param {*} vnode 新节点的 vnode\n * @param insertedVnodeQueue\n */\nfunction patchVnode(oldVnode, vnode, insertedVnodeQueue) {\n    // 如果两个虚拟dom一样，无需比较更新\n    if (oldVnode === vnode) return;\n\n    // 获取真实DOM\n    vnode.elm = oldVnode.elm;\n\n    // 钩子调用\n    let i;\n    const data = vnode.data;\n    if (data && !!(i = data.hook) && !!(i = i.prepatch)) {\n        i(oldVnode, vnode);\n    }\n\n    // 获取新老节点的孩子节点\n    const ch = vnode.children;\n    const oldCh = oldVnode.children;\n\n    if (!vnode.text) {  // 如果新节点没有文本节点\n        if (ch && oldCh) {  // 说明新老节点都有孩子节点\n            // 比较孩子节点 diff\n            updateChildren(ch, oldCh, insertedVnodeQueue);\n        } else if (ch) {  // 说明新节点有孩子节点，旧节点没有孩子节点\n            // 增加孩子节点\n        } else { // 说明新节点没有孩子节点，旧节点有孩子节点\n            // 删除孩子节点\n        }\n    } else if (oldVnode.text !== vnode.text) {  // 新节点有文本节点且跟旧节点不同\n        if (vnode.text.expression) {  // 说明存在表达式\n            // 获取表达式的新值\n            let value = vnode.context[vnode.text.expression];\n            value = typeof value === 'object' ? JSON.stringify(value) : value;\n            // 更新值\n            try {\n                const oldValue = oldVnode.elm.textConent;\n                if (value !== oldValue) {\n                    oldVnode.elm.textContent = value;\n                }\n            } catch (e) {\n                console.log(e);\n            }\n        }\n    }\n}\n\n/**\n * diff，比对孩子节点，找出不同点，然后将不同点更新到老节点上\n * @param {*} newCh 新 vnode 的所有孩子节点\n * @param {*} oldCh 老 vnode 的所有孩子节点\n * @param insertedVnodeQueue\n */\nfunction updateChildren(newCh, oldCh, insertedVnodeQueue) {\n    // 设置首位4个游标\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let newEndIdx = newCh.length - 1;\n    // 设置对应节点\n    let oldStartVnode = oldCh[0];\n    let newStartVnode = newCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndVnode = newCh[newEndIdx];\n\n    let oldKeyToIdx, idxInOld, vnodeToMove;\n\n    // 循环结束条件：新旧节点的头尾游标都重合\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (!oldStartVnode) {\n            // 当oldStartVnode为undefined的时候，oldStartVnode右移\n            oldStartVnode = oldCh[++oldStartIdx]\n        } else if (!oldEndVnode) {\n            // 当oldEndVnode为undefined的时候，oldEndVnode左移\n            oldEndVnode = oldCh[--oldEndIdx]\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n            // 当oldStartVnode与newStartVnode节点相同，对比节点\n            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n            // 更新对应游标\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n            // 当oldEndVnode与newEndVnode节点相同，对比节点\n            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n            // 更新对应游标\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) {\n            // 当oldStartVnode与newEndVnode节点相同，对比节点\n            patch(oldStartVnode, newStartVnode);\n            // 移动节点位置\n            oldStartVnode.elm.parentNode\n                .insertBefore(oldStartVnode.elm, oldCh[newEndIdx].elm.nextSibling);\n            // 更新对应游标\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) {\n            // 当oldEndVnode与newStartVnode节点相同，对比节点\n            patch(oldEndVnode, newStartVnode);\n            // 移动节点位置\n            oldEndVnode.elm.parentNode\n                .insertBefore(oldEndVnode.elm, oldCh[newStartIdx].elm);\n            // 更新对应游标\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        } else {  // 暴力解法\n            // 遍历剩余的旧孩子节点，将有key值的生成index表 <{key: i}>\n            if (!oldKeyToIdx) {\n                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n            }\n\n            // 如果newStartVnode存在key，就进行匹配index值；如果没有key值，遍历剩余的旧孩子节点，一一与newStartVnode匹配，相同节点的返回index\n            idxInOld = newStartVnode.key ?\n                oldKeyToIdx[newStartVnode.key] :\n                findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n\n            if (!idxInOld) {\n                // 如果匹配不到index，则创建新节点\n                createElm(newStartVnode, insertedVnodeQueue, newStartVnode.elm.parentNode, oldCh[newStartIdx].elm)\n            } else {\n                // 获取对应的旧孩子节点\n                vnodeToMove = oldCh[idxInOld];\n                if (sameVnode(vnodeToMove, newStartVnode)) {\n                    patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);\n                    // 因为idxInOld是处于oldStartIdx和oldEndIdx之间，因此只能将其设置为undefined，而不是移动两个游标\n                    oldCh[idxInOld] = undefined;\n                    // 移动节点\n                    oldEndVnode.elm.parentNode\n                        .insertBefore(vnodeToMove.elm, oldCh[newStartIdx].elm);\n                } else {\n                    // 如果key相同但节点不同，就创建一个新的节点\n                    createElm(newStartVnode, insertedVnodeQueue, newStartVnode.elm.parentNode, oldCh[newStartIdx].elm)\n                }\n            }\n            // 移动新节点的左边游标\n            newStartVnode = newCh[++newStartIdx]\n        }\n    }\n\n    if (oldStartIdx > oldEndIdx) {\n        // 当旧节点左游标已经超过右游标的时候，新增剩余的新的孩子节点\n        for (; newStartIdx <= newEndIdx; ++newStartIdx) {\n            createElm(newCh[newStartIdx], insertedVnodeQueue, newCh[newStartIdx].elm.parentNode, oldCh[newStartIdx].elm)\n        }\n    } else if (newStartIdx > newEndIdx) {\n        // 当新节点左游标已经超过右游标的时候，删除剩余的旧的孩子节点\n        for (; oldStartIdx <= oldEndIdx; ++oldStartIdx) {\n            const ch = oldCh[oldStartIdx];\n            if (ch) {\n                ch.parentNode.removeChild(ch);\n            }\n        }\n    }\n}\n\n/**\n * 判断两个节点是否相同\n */\nfunction sameVnode(a, b) {\n    return a.key === b.key && a.tag === b.tag\n}\n\n/**\n * 生成旧孩子节点的映射表\n */\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    let i, key\n    const map = {}\n    for (i = beginIdx; i <= endIdx; ++i) {\n        key = children[i].key\n        if (key) map[key] = i\n    }\n    return map\n}\n\n/**\n * 遍历匹配找到相同节点下标\n */\nfunction findIdxInOld(node, oldCh, start, end) {\n    for (let i = start; i < end; i++) {\n        const c = oldCh[i]\n        if (c && sameVnode(node, c)) return i\n    }\n}\n\n/**\n * 自定义组件创建过程\n * @param {*} vnode\n * @param insertedVnodeQueue\n * @param {*} parent 父节点，真实节点\n * @param {*} referNode 参考节点\n */\nfunction createComponent(vnode,insertedVnodeQueue, parent, referNode) {\n    let i = vnode.data;\n    if (i) {\n        // 获取组件init钩子\n        if (!!(i = i.hook) && !!(i = i.init)) {\n            // 组件实例化和挂载，执行init方法\n            i(vnode);\n        }\n        if (vnode.componentInstance) {\n            insertedVnodeQueue.push(vnode);\n            // 插入到dom节点\n            vnode.elm = vnode.componentInstance._vnode.elm;\n            parent.insertBefore(vnode.elm, referNode);\n            return true;\n        }\n    }\n}\n\n/**\n * 判断是否为组件，添加到insertedVnodeQueue\n * */\nfunction invokeCreateHooks(vnode, insertedVnodeQueue) {\n    let i = vnode.data.hook;\n    if(i) {\n        if(i.insert) insertedVnodeQueue.push(vnode);\n    }\n}\n\n/**\n * 调用组件insert钩子\n * */\nfunction invokeInsertHook(queue) {\n    for (let i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i])\n    }\n}\n","export class VNode {\n    constructor(tag, data, children, text, elm, context, componentOptions) {\n        this.tag = tag;  // 标签\n        this.data = data;  // 属性\n        this.children = children;  // 孩子节点\n        this.text = text;  // 文本内容\n        this.elm = elm;   // 真实dom\n        this.context = context; // 执行上下文\n        this.parent = undefined;\n        this.key = data && data.key;\n        this.componentOptions = componentOptions;\n        this.componentInstance = undefined;\n    }\n}\n\n/**\n * createEmptyVNode: 创建空的VNode\n * @return VNode\n */\nexport function createEmptyVNode() {\n    return new VNode()\n}\n\n/**\n * createTextNode: 创建文本VNode\n * @return VNode\n */\nexport function createTextNode(val) {\n    return new VNode(null, null, null, val, null, this);\n}\n","import {VNode} from \"./vnode\";\nimport {activeInstance, updateChildComponent} from \"../instance/lifecycle\";\nimport {callHook} from \"../instance/lifecycle\";\n\n\n// 组件管理钩子的定义\nconst componentVNodeHooks = {\n    // 组件初始化钩子\n    init(vnode) {\n        console.log('Component init hook');\n        // 创建自定义组件实例\n        const child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);\n        // 执行挂载\n        child.$mount(vnode.elm || undefined);\n\n    },\n\n    // 组件更新前钩子\n    prepatch(oldVnode, vnode) {\n        console.log('Component prepatch hook')\n        const options = vnode.componentOptions;\n        const child = vnode.componentInstance = oldVnode.componentInstance;\n        updateChildComponent(\n            child,\n            options.propsData,\n            options.listeners,\n            vnode,\n            options.children\n        )\n    },\n\n    // 组件插入dom节点钩子\n    insert(vnode) {\n        console.log('Component insert hook')\n        const {componentInstance} = vnode\n        if (!componentInstance._isMounted) {\n            componentInstance._isMounted = true\n            callHook(componentInstance, 'mounted')\n        }\n    },\n\n\n    // 组件销毁钩子\n    destroy() {}\n}\n\nconst hooksToMerge = Object.keys(componentVNodeHooks)\n\n/**\n * 创建组件vnode\n * @param Ctor 组件构造函数\n * @param data 组件属性\n * @param context 组件上下文\n * @param children 孩子节点\n * @param tag 组件标签\n * */\nexport function createComponent(Ctor, data = {}, context, children, tag) {\n    // 安装组件管理钩子\n    installComponentHooks(data);\n\n    // 自定义组件\n    const name = Ctor.options.name || tag;\n\n    // 获取组件props\n    const propOptions = Ctor.options.props;\n    const propsData = {};\n    // 获取绑定属性\n    const {vBind: props} = data;\n    if(props) {\n        for(const key in propOptions){\n            // 获取props值\n            propsData[key] = context[props[key]] || undefined;\n        }\n    }\n    Ctor.options.propsData = propsData;\n\n    // 获取组件listeners\n    const listeners = data.vOn;\n    Ctor.options._parentListeners = listeners;\n\n    // 创建vnode\n    const vnode = new VNode(\n        `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,\n        data, children, undefined, undefined, context,\n        {Ctor, tag, children, propsData, listeners});\n\n    return vnode;\n}\n\n/**\n * 管理钩子：合并用户编写的钩子和系统默认的钩子（hooksToMerge）\n * */\nfunction installComponentHooks(data) {\n    const hooks = data.hook || (data.hook = {});\n    for(let i = 0; i < hooksToMerge.length; i++) {\n        const key = hooksToMerge[i];\n        hooks[key] = componentVNodeHooks[key];\n    }\n}\n\n/*\n* 创建组件实例\n* */\nfunction createComponentInstanceForVnode(vnode, parent) {\n    // 合并父组件实例\n    const options = {\n        _isComponent: true,\n        _parentVnode: vnode,\n        parent\n    }\n\n    // 创建自定义组件实例\n    return vnode.componentOptions.Ctor(options);\n}\n","import {createEmptyVNode, VNode} from \"./vnode\";\nimport {createComponent} from \"./create-component\"\n\n/**\n * createElement: 将传入的组件配置转换为VNode\n * @param context<Object>: 执行上下文\n * @param tag<string>: 标签\n * @param data<Object>: 属性\n * @param children<Object>: 孩子节点\n */\nexport function createElement(context, tag, data, children) {\n    // 如果没有标签，返回空的Vnode\n    if (!tag) return createEmptyVNode();\n\n    let vnode;\n    let Ctor;  // 构造函数\n    if (isReservedTag(tag)) {\n        // 保留标签\n        vnode = new VNode(tag, data, children, undefined, undefined, context);\n    } else if (!!(Ctor = context.$options.components[tag])) {\n        vnode = createComponent(Ctor, data, context, children, tag);\n    }\n    return vnode;\n}\n\n/**\n * isReservedTag: 判断是否为保留标签\n * @param tag<string>: 标签\n */\nexport function isReservedTag(tag) {\n    return isHTMLTag(tag) || isSVG(tag);\n}\n\nexport const isHTMLTag = makeMap(\n    'html,body,base,head,link,meta,style,title,' +\n    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n    'embed,object,param,source,canvas,script,noscript,del,ins,' +\n    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n    'output,progress,select,textarea,' +\n    'details,dialog,menu,menuitem,summary,' +\n    'content,element,shadow,template,blockquote,iframe,tfoot'\n)\n\nexport const isSVG = makeMap(\n    'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n    true\n)\n\nfunction makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(',');\n    for (let i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase\n        ? function (val) {\n            return map[val.toLowerCase()];\n        }\n        : function (val) {\n            return map[val];\n        }\n}\n","import {createElement} from \"../vdom/create-element\";\nimport {createTextNode} from \"../vdom/vnode\";\nimport {defineReactive} from \"../observer/index\";\n\n/**\n * initRender: 初始化render属性\n * @param vm<Object>: Vue实例\n */\nexport function initRender(vm) {\n    // 定义render参数createElement\n    vm._c = createElement;\n    vm._v = createTextNode;\n\n    // 定义$attrs和$listeners的响应式\n    const options = vm.$options\n    const parentVnode = vm.$vnode = options._parentVnode;\n    const parentData = parentVnode && parentVnode.data;\n    defineReactive(vm, '$attrs', parentData && parentData.data || {});\n    defineReactive(vm, '$listeners', options._parentListeners || {});\n}\n","// 合并选项\nexport function mergeOptions(parent, child) {\n    if(!child) return parent;\n\n    if(typeof child === 'function') {\n        child = child.options;\n    }\n\n    const options = {};\n    let key;\n    for(key in parent) {\n        mergeField(key)\n    }\n    for (key in child) {\n        if (!hasOwn(parent, key)) {\n            mergeField(key)\n        }\n    }\n\n    function mergeField(key) {\n        const strat = defaultStrat;\n        options[key] = strat(parent[key], child[key])\n    }\n    return options\n}\n\nconst defaultStrat = function (parentVal = undefined, childVal) {\n    return childVal === undefined\n        ? parentVal\n        : childVal\n}\n\nfunction hasOwn (obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key)\n}\n","/**\n * initLifecycle: 初始化事件监听\n * @param vm: 组件实例\n */\nexport function initEvents(vm) {\n    vm._events = Object.create(null);\n    const listeners = vm.$options._parentListeners;\n    if(listeners) {\n        for(let name in listeners) {\n            // 事件绑定\n            vm.$on(name, vm.$parent[listeners[name]]);\n        }\n    }\n}\n","/**\n * initLifecycle: 初始化provide\n * @param vm: 组件实例\n */\nimport {defineReactive} from \"../observer/index\";\n\nexport function initProvide(vm) {\n    const provide = vm.$options.provide;\n    if (provide) {\n        vm._provided = typeof provide === 'function'\n            ? provide.call(vm)\n            : provide\n    }\n}\n\n\n/**\n * initLifecycle: 初始化inject\n * @param vm: 组件实例\n */\nexport function initInjections(vm) {\n    const result = resolveInject(vm.$options.inject, vm);\n    // 响应式处理\n    if(result) {\n        Object.keys(result).forEach(key => {\n            defineReactive(vm, key, result[key])\n        })\n    }\n}\n\n\nfunction resolveInject(inject, vm) {\n    if (inject) {\n        const result = Object.create(null);\n\n        inject.forEach(provideKey => {\n            // 递归查找\n            let source = vm;\n            while (source) {\n                if (source._provided && Object.keys(source._provided).includes(provideKey)) {\n                    result[provideKey] = source._provided[provideKey]\n                    break\n                }\n                source = source.$parent;\n            }\n        })\n\n        return result;\n    }\n}\n","import {initState} from \"./state\"\nimport {initLifecycle, mountComponent, callHook, setActiveInstance} from \"./lifecycle\";\nimport {set, del} from \"../observer/index\";\nimport {Watcher} from \"../observer/watcher\";\nimport {popTarget, pushTarget} from \"../observer/dep\";\nimport compileToFunction from \"../compiler/index\"\nimport {patch} from \"../vdom/patch\";\nimport {initRender} from \"./render\";\nimport {nextTick} from \"../util/next-tick\";\nimport {mergeOptions} from \"../util/options\";\nimport {initEvents} from \"./events\";\nimport {initInjections, initProvide} from \"./inject\";\n\n/**\n * Vue:\n * @param options<Object>: 包含el、data、methods等等\n */\nexport class Vue {\n    __patch__ = patch;\n    $nextTick = (fn) => nextTick(fn, this);\n\n    constructor(options) {\n        // 定义了只读属性$data和$props\n        Object.defineProperty(this, '$data', {\n            get() {\n                return this._data\n            }\n        })\n        Object.defineProperty(this, '$props', {\n            get() {\n                return this._props\n            }\n        })\n\n        // 设置响应式数据\n        this.$set = set;\n        // 删除响应式数据\n        this.$delete = del;\n\n        // 初始化选项\n        this._init(options);\n    }\n\n    /**\n     * $watch: 数据监听\n     * @param expOrFn: 更新函数\n     * @param cb\n     */\n    $watch(expOrFn, cb) {\n        const watcher = new Watcher(this, expOrFn, cb);\n        // 收集依赖\n        pushTarget();\n        cb.apply(this, [watcher.value]);\n        popTarget();\n    }\n\n    /**\n     * _init: Vue初始化处理\n     */\n    _init(options) {\n        this.vm = this;\n\n        // 合并选项\n        this.vm.$options = mergeOptions(\n            this.vm.constructor.options || {},\n            options)\n\n        initLifecycle(this)   // 设置$parent、$children等组件关系属性\n        initEvents(this)   // 监听附加在组件上的事件\n        initRender(this)    // 初始化组件插槽$slot、声明createElement方法\n        callHook(this, 'beforeCreate')  // 调用beforeCreate生命周期钩子\n        initInjections(this) //  初始化注入数据 resolve injections before data/props\n        initState(this)   // 初始化组件的props/methods/data/computed/watch\n        initProvide(this) // 为后代提供数据 resolve provide after data/props\n\n        callHook(this, 'created')  // 调用created生命周期钩子\n\n        // 当设置了el选项时，自动调用$mount\n        if (this.$options.el) {\n            this.$mount(this.$options.el)\n        }\n    }\n\n    /**\n     * $mount: 组件挂载\n     * @param el\n     */\n    $mount(el) {\n        // 获得宿主\n        this.$el = el && document.querySelector(el);\n\n        // 查找render选项，若不存在render选项则将template/el的设置转换为render函数\n        if (!this.$options.render) {\n            // 获取template选项\n            let template = this.$options.template;\n            if (template) {\n                // 解析template选项\n                if (typeof template === 'string') {\n                    // 标签id\n                    if (template.charAt(0) === '#') {\n                        template = document.querySelector(template).innerHTML\n                    }\n                } else if (template.nodeType) {\n                    // 节点\n                    template = template.innerHTML\n                }\n            } else if (el) {\n                // 否则解析el选项\n                template = document.querySelector(el).outerHTML;\n            }\n\n            // 获取到html模板字符串之后，执行编译过程\n            if (template) {\n                const render = compileToFunction(template);\n                this.$options.render = render;\n            }\n        }\n\n        return mountComponent(this, el);\n    }\n\n\n    /**\n     * _render: 负责执行vm.$options.render 函数\n     */\n    _render() {\n        // 获取组件render选项和父级虚拟DOM\n        const {render, _parentVnode} = this.$options;\n\n        // 给render函数绑定this上下文为Vue实例\n        const vnode = render.apply(this);\n\n        // 设置父级虚拟dom，为了保证render函数能够执行\n        this.$vnode = _parentVnode\n\n        return vnode;\n\n    }\n\n    /**\n     * _update: 更新函数\n     * @param vnode 新的vnode\n     */\n    _update(vnode) {\n        // 获取老的VNode\n        const preVNode = this._vnode;\n        // 新的VNode\n        this._vnode = vnode;\n        // 设置ActiveInstance\n        const restoreActiveInstance = setActiveInstance(this);\n\n        if (!preVNode) {\n            // 老的VNode不存在的话，则说明是首次渲染组件\n            this.$el = this.__patch__(this.$el, vnode);\n        } else {\n            // 更新组件或者首次渲染子组件\n            this.$el = this.__patch__(preVNode, vnode);\n        }\n\n        // 重置ActiveInstance\n        restoreActiveInstance();\n    }\n\n    /**\n     * $on 事件绑定\n     * */\n    $on(event, fn) {\n        (this._events[event] || (this._events[event] = [])).push(fn);\n        return this;\n    }\n\n    /**\n     * $off 事件解绑\n     * */\n    $off(event) {\n        const cbs = this._events[event];\n        if (!cbs) {\n            return this;\n        }\n\n        this._events[event] = null;\n        return this;\n    }\n\n    /**\n     * $once 事件绑定，只执行一次\n     * */\n    $once(event, fn) {\n        function on () {\n            this.$off(event);\n            fn.apply(this, arguments);\n        }\n        on.fn = fn;\n        this.$on(event, on);\n        return this;\n    }\n\n    /**\n     * $once 事件派发\n     * */\n    $emit(event, ...args) {\n        let cbs = this._events[event];\n        if(cbs) {\n            cbs.forEach(cb => {\n                cb.apply(this, args)\n            })\n        }\n        return this;\n    }\n}\n","export const ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n]\n","import {mergeOptions} from \"../util/options\"\nimport {ASSET_TYPES} from \"../shared/constants\";\nimport {Vue} from \"../instance/index\";\n\nexport function initExtend(Vue) {\n    Vue.cid = 0;\n    let cid = 1;\n\n    Vue.extend = function (extendOptions = {}) {\n        const Super = this;\n        const SuperId = Super.cid;\n        const name = extendOptions.name || Super.options.name\n\n        const Sub = function VueComponent(options) {\n            return new Vue({\n                ...options,\n                ...Sub.options\n            }); // 初始化\n        }\n\n        // 继承\n        Sub.prototype = Object.create(Super.prototype);\n        Sub.prototype.constructor = Sub;\n        Sub.cid = cid++;\n        Sub.options = mergeOptions(Super.options, extendOptions);\n        Sub['super'] = Super;\n\n        Sub.extend = Super.extend\n        Sub.mixin = Super.mixin\n        Sub.use = Super.use\n\n        ASSET_TYPES.forEach(function (type) {\n            Sub[type] = Super[type]\n        })\n\n        if (name) {\n            Sub.options.components[name] = Sub\n        }\n\n        Sub.superOptions = Super.options\n        Sub.extendOptions = extendOptions\n\n        return Sub\n    }\n}\n","import {ASSET_TYPES} from \"../shared/constants\"\n\nexport function initAssetRegisters(Vue) {\n    ASSET_TYPES.forEach(type => {\n        // 声明静态的方法 Vue.component =  function(){}\n        Vue[type] = function (id, definition) {\n            if(type === 'component') {\n                // name设置\n                definition.name = definition.name || id;\n                // 将传入的组件配置对象转换为组件构造函数\n                definition = this.options._base.extend(definition);\n\n                // 向全局的选项中加入全局组件配置对象\n                this.options[type + 's'][id] = definition;\n\n                return definition;\n            }\n        }\n    })\n}\n","import {set,del} from \"../observer/index\"\nimport {nextTick} from \"../util/next-tick\";\nimport {initExtend} from \"./extend\";\nimport {initAssetRegisters} from \"./assets\"\nimport {ASSET_TYPES} from \"../shared/constants\"\n\nexport function initGlobalAPI(Vue) {\n    Vue.set = set             // 实现Vue.set\n    Vue.delete = del       // 实现Vue.delete\n    Vue.nextTick = nextTick     // 实现Vue.nextTick\n\n    // 实现Vue.options\n    Vue.options = Object.create(null)\n    // 遍历数组：components、filters、directives\n    ASSET_TYPES.forEach(type => {\n        Vue.options[type + 's'] = Object.create(null)  // 空对象\n    })\n    Vue.options._base = Vue\n\n    initExtend(Vue);   // 实现Vue.extend函数\n    initAssetRegisters(Vue); // 注册实现Vue.component、directive、filter\n}\n","import {Vue} from \"./instance/index\";\nimport {initGlobalAPI} from \"./global-api/index\";\n\n// 初始化全局API （component、filter、directive、use、mixin、util、extend...）\ninitGlobalAPI(Vue)\n\nexport default Vue;\n"],"names":["uid","Dep","id","subs","sub","push","forEach","dep","update","target","addDep","this","targetStack","pushTarget","popTarget","pop","length","observe","value","_typeof","Observer","Object","defineProperty","Array","isArray","copyAugment","observeArray","walk","items","i","l","obj","keys","key","defineReactive","ob","__ob__","original","prototype","arrayProto","create","method","inserted","args","apply","slice","notify","__proto__","val","childOb","get","depend","dependArray","set","newVal","v","del","p","timerFunc","counter","observer","textNode","callbacks","pending","flushCallbacks","copies","nextTick","cb","ctx","call","Promise","resolve","then","MutationObserver","document","createTextNode","String","characterData","data","setImmediate","setTimeout","queue","has","waiting","flushing","index","resetSchedulerState","flushSchedulerQueue","watcher","sort","a","b","run","queueWatcher","splice","Watcher","vm","expOrFn","depIds","Set","deps","getter","parsePath","oldValue","add","addSub","path","segments","split","sharedPropertyDefinition","enumerable","configurable","initState","opts","$options","props","initProps","methods","initMethods","initData","_data","computed","initComputed","watch","initWatch","res","proxy","sourceKey","watchers","_computedWatchers","userDef","handler","createWatcher","$watch","propsOptions","propsData","_props","_propKeys","prop","bind","activeInstance","initLifecycle","parent","$children","$parent","$root","$refs","mountComponent","hook","callHook","_update","_render","$vnode","e","console","log","setActiveInstance","prevActiveInstance","updateChildComponent","listeners","parentVnode","_parentVnode","_vnode","parse","template","text","textAst","stack","root","html","trim","startIdx","indexOf","processElement","end","content","firstSpaceIdx","tagName","attrsStr","attrMap","attrs","len","attrName","attrValue","replace","parseAttrs","elementAst","type","tag","rawAttr","children","includes","isUnaryTag","parseStartTag","match","expression","RegExp","$1","curEle","stackLen","bindKey","propertyArr","vModelVal","vModel","find","item","vBind","vOnKey","vOn","generate","ast","renderStr","genElement","Function","datas","genChildren","JSON","stringify","child","compileToFunction","patch","oldVnode","vnode","insertedVnodeQueue","nodeType","createElm","parentNode","nextSibling","removeChild","patchVnode","invokeInsertHook","elm","referNode","createComponent","invokeCreateHooks","createElement","setAttribute","insertBefore","appendChild","textVNode","context","name","setVModel","setVBind","setVOn","addEventListener","checked","removeAttribute","eventName","prepatch","ch","oldCh","textConent","textContent","updateChildren","newCh","oldKeyToIdx","idxInOld","vnodeToMove","oldStartIdx","newStartIdx","oldEndIdx","newEndIdx","oldStartVnode","newStartVnode","oldEndVnode","newEndVnode","sameVnode","createKeyToOldIdx","findIdxInOld","undefined","beginIdx","endIdx","map","node","start","c","init","componentInstance","insert","VNode","componentOptions","createEmptyVNode","componentVNodeHooks","createComponentInstanceForVnode","$mount","options","_isMounted","destroy","hooksToMerge","Ctor","installComponentHooks","propOptions","_parentListeners","cid","hooks","_isComponent","isReservedTag","components","isHTMLTag","isSVG","makeMap","str","expectsLowerCase","list","toLowerCase","initRender","_c","_v","parentData","mergeOptions","mergeField","hasOwn","strat","defaultStrat","parentVal","childVal","hasOwnProperty","initEvents","_events","$on","initProvide","provide","_provided","initInjections","result","resolveInject","inject","provideKey","source","Vue","fn","_this","$set","$delete","_init","constructor","el","render","$el","querySelector","charAt","innerHTML","outerHTML","preVNode","restoreActiveInstance","__patch__","event","on","$off","arguments","cbs","_this2","ASSET_TYPES","initExtend","extend","extendOptions","Super","Sub","mixin","use","superOptions","initAssetRegisters","definition","_base","initGlobalAPI"],"mappings":"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"}